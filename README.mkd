##Overview

Symmusic is meant for poorly-named music collections which you don't want to manipulate, but would like a nicer way of browsing. It recursively reads a directory for audio tags and builds a nice directory structure from them. The bottom-level audio files are then symbolically linked to their originating file. This allows one to keep multiple directories organized by artist, genre, album, etc without much disk overhead even for large music collections.

[pytagsfs][] is an awesome already implemented version of what I'm trying to do. Its much more flexible then what this script will ever be. For instance, it lets your edit your metadata on the fly by simply rearranging material in the virtual filesystem, and can smartly exclude compilations.

Why reinvent then? Pytagfs runs through fuse, and its map of metadata is stored in memory. This is fine for one-view of a not-too-large music collection. But if you're storing a big music collection, and want to have it listed multiple ways (by artist, by album, by genre) the resources can add up quick. This script is quicker than starting up pytagsfs on a large directory, and doesn't use resources once its done. 

Why do this? 1--I need a bigger python project to learn on. 2--I want to be able to read through my music library easily with any file-based program. 

##Features?

* Works with mp3, FLAC, OGGVorbis. Can choose 1, 2 or all 3. 
* allow command line specification of hierarchy.
* Return simple count of found files and created symbolic links.

###TODO

* Warning/Fail on Windows (DONE)
	- Longer term, find windows workaround for symbolic links
* Update only changed/new files in directory (with option for length of time)
* Warning for --dst inside of --src. (DONE)
* Allow complex directory specification (e.g. multiple tags)

##Use

###Command line options

* *--formats* (*-f*): specify audio formats to search and parse
	- *options*: mp3 , ogg , flac
	- *default*: All (mp3, ogg, flac)
* *--dn* : directory names. **Required**.
	- each argument will create a directory level. Follows given order.
	- *options*: %a (artist), %l (album), %g (genre), %n (track number), %t (track title), %y (year/date)
	- *note*: albums (%l) will be appended with file extensions.
* *--fn* : File name. **Required**.
	- each argument will be added to the file name separated by a hyphen. All files will have proper file extension added.
	- *options*: %a (artist), %l (album), %g (genre), %n (track number), %t (track title), %y (year/date)
* *--src* : Directory to search for music files.
	- will be searched recursively. 
	- *default*: current working directory.
* *--dst* : Directory to build new file structure in. **Required**.


###Examples

A basic syntax example:

		symmusic.py --dn %a %l --fn %n %t --src /home/user/music --dst /home/user/music-by-artist

This will read a users ../music directory, and create a new directory structure in ../music-by-artist. The new structure will have three levels: artist (a) > album (l) > filenames (n t). Note that directory structure is based on order of options, with the leftmost option being the highest level directory. The filename is the track number (n), and title (t). Symbolic links will resolve back to the ../music directory. All except the '--src' argument are required (--src defaults to the working directory if not specified.)

* Sort only mp3s by: Genre / Artist / Album. Filename is Number - Title:

		symmusic.py --formats mp3 --dn %g %a %l --fn %t --src /music --dst /by-genre

* Sort by: Year / Genre / Album. Filename is Artist - Title:

		symmusic.py --dn %y %g %l --fn %a %t --src /music --dst /by-year

* Sort by: Album. Filename is Artist - Year - Title:

		symmusic.py --dn %l --fn %a %y %t --src /music --dst /by-album

####Caveats / Oddities

* All albums are appended with a tag of what filetype the contain. So "The White Album" becomes "The White Album [.mp3]". This is something my own collection needs because I often have flac and mp3 versions of the same files. 

* When a metadata tag can't be read it *should* return 'Unknown'. The effect is you might have 'unknown' directories in each level of your hierarchy. 

* I wouldn't put much faith in the 'files created' number that is printed. Its a dumb counter. 

###Dependencies

* UNIX-like OS. (Linux, Mac OSX)
* Python (2.6)
* [mutagen][] -- a python module to handle audio metatdata



[pytagsfs]: http://www.pytagsfs.org/
[mutagen]: http://code.google.com/p/mutagen/
[unidecode]: http://pypi.python.org/pypi/Unidecode/ 

